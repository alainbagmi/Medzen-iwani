-- Migration: Fix clinical notes trigger and re-enable RLS
-- Description: Properly recreate trigger with correct UUID handling and restore RLS

-- =============================================================================
-- STEP 1: Drop any existing trigger functions and triggers
-- =============================================================================
DROP TRIGGER IF EXISTS tr_sync_signed_note ON clinical_notes;
DROP TRIGGER IF EXISTS tr_clinical_note_sync_on_sign ON clinical_notes;
DROP TRIGGER IF EXISTS tr_clinical_note_sync_on_insert ON clinical_notes;
DROP FUNCTION IF EXISTS fn_queue_signed_clinical_note() CASCADE;
DROP FUNCTION IF EXISTS fn_queue_clinical_note_for_ehrbase_sync() CASCADE;

-- =============================================================================
-- STEP 2: Create the trigger function with proper UUID handling
-- Key fix: No UUID::text comparisons in WHERE clauses
-- =============================================================================
CREATE OR REPLACE FUNCTION fn_queue_clinical_note_sync()
RETURNS TRIGGER AS $$
DECLARE
    v_ehr_id TEXT;
    v_patient_name TEXT;
    v_provider_name TEXT;
    v_provider_specialty TEXT;
BEGIN
    -- Only process when status becomes 'final' (signed)
    IF NEW.status = 'final' AND (OLD IS NULL OR OLD.status IS DISTINCT FROM 'final') THEN

        -- Get patient's EHR ID
        -- Note: patient_id and id are both UUID types, no casting needed
        SELECT u.ehr_id, u.first_name || ' ' || u.last_name
        INTO v_ehr_id, v_patient_name
        FROM users u
        WHERE u.id = NEW.patient_id;

        -- Skip if patient has no EHR ID
        IF v_ehr_id IS NULL OR v_ehr_id = '' THEN
            RAISE NOTICE 'Clinical note % skipped: patient % has no EHR ID', NEW.id, NEW.patient_id;
            RETURN NEW;
        END IF;

        -- Get provider details
        SELECT u.first_name || ' ' || u.last_name
        INTO v_provider_name
        FROM users u
        WHERE u.id = NEW.provider_id;

        -- Get provider specialty
        SELECT COALESCE(mpp.primary_specialization, mpp.professional_role, 'General Practice')
        INTO v_provider_specialty
        FROM medical_provider_profiles mpp
        WHERE mpp.user_id = NEW.provider_id;

        -- Check if already queued (prevent duplicates)
        -- Use text comparison for record_id since that column is TEXT type
        IF NOT EXISTS (
            SELECT 1 FROM ehrbase_sync_queue
            WHERE table_name = 'clinical_notes'
            AND record_id = NEW.id::text  -- record_id is TEXT, so cast here is correct
            AND sync_status IN ('pending', 'processing')
        ) THEN
            -- Insert into sync queue
            INSERT INTO ehrbase_sync_queue (
                table_name,
                record_id,
                template_id,
                sync_type,
                sync_status,
                ehr_id,
                retry_count,
                data_snapshot,
                created_at
            ) VALUES (
                'clinical_notes',
                NEW.id::text,  -- record_id is TEXT type
                'medzen.clinical.notes.v1',
                'create',
                'pending',
                v_ehr_id,
                0,
                jsonb_build_object(
                    'note_id', NEW.id::text,
                    'appointment_id', COALESCE(NEW.appointment_id::text, ''),
                    'session_id', COALESCE(NEW.session_id::text, ''),
                    'patient_id', NEW.patient_id::text,
                    'patient_name', COALESCE(v_patient_name, 'Unknown Patient'),
                    'provider_id', NEW.provider_id::text,
                    'provider_name', COALESCE(v_provider_name, 'Unknown Provider'),
                    'provider_specialty', COALESCE(v_provider_specialty, 'General Practice'),
                    'note_type', NEW.note_type,
                    'chief_complaint', COALESCE(NEW.chief_complaint, ''),
                    'history_of_present_illness', COALESCE(NEW.history_of_present_illness, ''),
                    'subjective', COALESCE(NEW.subjective, ''),
                    'objective', COALESCE(NEW.objective, ''),
                    'assessment', COALESCE(NEW.assessment, ''),
                    'plan', COALESCE(NEW.plan, ''),
                    'icd10_codes', COALESCE(NEW.icd10_codes, '[]'::jsonb),
                    'cpt_codes', COALESCE(NEW.cpt_codes, '[]'::jsonb),
                    'medical_entities', COALESCE(NEW.medical_entities, '{}'::jsonb),
                    'signed_by', COALESCE(NEW.provider_signature, ''),
                    'signed_at', COALESCE(NEW.signed_at::text, ''),
                    'transcript_language', COALESCE(NEW.transcript_language, 'en')
                ),
                NOW()
            );

            -- Update ehrbase_sync_status on the clinical note
            NEW.ehrbase_sync_status := 'queued';

            RAISE NOTICE 'Clinical note % queued for EHRbase sync (patient: %, ehr_id: %)',
                NEW.id, NEW.patient_id, v_ehr_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION fn_queue_clinical_note_sync() TO authenticated, service_role;

-- =============================================================================
-- STEP 3: Create triggers for UPDATE and INSERT
-- =============================================================================

-- Trigger for when status is updated to 'final'
CREATE TRIGGER tr_clinical_note_sync
    BEFORE UPDATE ON clinical_notes
    FOR EACH ROW
    WHEN (NEW.status = 'final')
    EXECUTE FUNCTION fn_queue_clinical_note_sync();

-- Trigger for when a new note is inserted as 'final' (directly signed)
CREATE TRIGGER tr_clinical_note_sync_insert
    BEFORE INSERT ON clinical_notes
    FOR EACH ROW
    WHEN (NEW.status = 'final')
    EXECUTE FUNCTION fn_queue_clinical_note_sync();

-- =============================================================================
-- STEP 4: Re-enable RLS with proper policies
-- =============================================================================
ALTER TABLE clinical_notes ENABLE ROW LEVEL SECURITY;

-- Drop all existing policies
DROP POLICY IF EXISTS "clinical_notes_select_policy" ON clinical_notes;
DROP POLICY IF EXISTS "clinical_notes_insert_policy" ON clinical_notes;
DROP POLICY IF EXISTS "clinical_notes_update_policy" ON clinical_notes;
DROP POLICY IF EXISTS "clinical_notes_delete_policy" ON clinical_notes;
DROP POLICY IF EXISTS "clinical_notes_select_own" ON clinical_notes;
DROP POLICY IF EXISTS "clinical_notes_insert_provider" ON clinical_notes;
DROP POLICY IF EXISTS "clinical_notes_update_own" ON clinical_notes;

-- Create policies that work with both Firebase auth (auth.uid() IS NULL) and service role

-- SELECT: Users can view clinical notes for their appointments
CREATE POLICY "clinical_notes_select" ON clinical_notes
    FOR SELECT USING (
        auth.uid() IS NULL  -- Allow Firebase auth users (no Supabase session)
        OR patient_id = auth.uid()  -- Patient can see their notes
        OR provider_id = auth.uid() -- Provider can see notes they created
    );

-- INSERT: Only providers can create clinical notes
CREATE POLICY "clinical_notes_insert" ON clinical_notes
    FOR INSERT WITH CHECK (
        auth.uid() IS NULL  -- Allow Firebase auth users
        OR provider_id = auth.uid()  -- Provider is the one creating
    );

-- UPDATE: Provider can update their own notes
CREATE POLICY "clinical_notes_update" ON clinical_notes
    FOR UPDATE USING (
        auth.uid() IS NULL  -- Allow Firebase auth users
        OR provider_id = auth.uid()
    ) WITH CHECK (
        auth.uid() IS NULL
        OR provider_id = auth.uid()
    );

-- DELETE: Only system admins (via service role) or the provider can delete
CREATE POLICY "clinical_notes_delete" ON clinical_notes
    FOR DELETE USING (
        auth.uid() IS NULL  -- Allow Firebase auth (service handles validation)
        OR provider_id = auth.uid()
    );

-- =============================================================================
-- STEP 5: Add comment for documentation
-- =============================================================================
COMMENT ON FUNCTION fn_queue_clinical_note_sync() IS
'Queues signed clinical notes (status=final) for EHRbase/OpenEHR sync.
Only queues if patient has an ehr_id. Uses BEFORE trigger to also update
ehrbase_sync_status on the note.';

-- =============================================================================
-- Done!
-- =============================================================================
