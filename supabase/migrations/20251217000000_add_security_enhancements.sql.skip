-- ============================================
-- MedZen Phase 1 Security Enhancements
-- Database Migration
-- ============================================
-- Creates tables and functions for:
-- 1. Meeting quota enforcement (10/day, 100/month)
-- 2. HIPAA audit logging for video calls
-- 3. Security event tracking
--
-- Migration: 20251217000000_add_security_enhancements.sql
-- Author: System
-- Date: 2025-12-17

-- ============================================
-- 1. Meeting Quotas Table
-- ============================================

CREATE TABLE IF NOT EXISTS meeting_quotas (
  user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
  meetings_created_today INTEGER DEFAULT 0 CHECK (meetings_created_today >= 0),
  meetings_created_this_month INTEGER DEFAULT 0 CHECK (meetings_created_this_month >= 0),
  quota_reset_date DATE DEFAULT CURRENT_DATE,
  monthly_quota_reset_date DATE DEFAULT DATE_TRUNC('month', CURRENT_DATE)::DATE,
  daily_quota_limit INTEGER DEFAULT 10,  -- Configurable per user
  monthly_quota_limit INTEGER DEFAULT 100,  -- Configurable per user
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE meeting_quotas IS 'Tracks meeting creation quotas per user to prevent abuse';
COMMENT ON COLUMN meeting_quotas.daily_quota_limit IS 'Maximum meetings per day (default: 10)';
COMMENT ON COLUMN meeting_quotas.monthly_quota_limit IS 'Maximum meetings per month (default: 100)';

-- Index for efficient quota lookups
CREATE INDEX IF NOT EXISTS idx_meeting_quotas_user_id ON meeting_quotas(user_id);
CREATE INDEX IF NOT EXISTS idx_meeting_quotas_reset_dates ON meeting_quotas(quota_reset_date, monthly_quota_reset_date);

-- Enable RLS
ALTER TABLE meeting_quotas ENABLE ROW LEVEL SECURITY;

-- Users can only view their own quotas
CREATE POLICY "users_view_own_quotas" ON meeting_quotas
FOR SELECT USING (auth.uid() = user_id);

-- System admins can view all quotas
CREATE POLICY "admins_view_all_quotas" ON meeting_quotas
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role = 'system_admin'
  )
);

-- Only system can insert/update quotas (through triggers/functions)
CREATE POLICY "system_only_modify_quotas" ON meeting_quotas
FOR ALL USING (false);

-- ============================================
-- 2. Quota Enforcement Function
-- ============================================

CREATE OR REPLACE FUNCTION check_meeting_quota(p_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_quota RECORD;
  v_daily_limit INTEGER;
  v_monthly_limit INTEGER;
BEGIN
  -- Get current quota or create if doesn't exist
  SELECT * INTO v_quota FROM meeting_quotas WHERE user_id = p_user_id;

  IF NOT FOUND THEN
    -- First time user - create quota record
    INSERT INTO meeting_quotas (user_id)
    VALUES (p_user_id);
    RETURN TRUE;
  END IF;

  -- Get limits (use defaults if NULL)
  v_daily_limit := COALESCE(v_quota.daily_quota_limit, 10);
  v_monthly_limit := COALESCE(v_quota.monthly_quota_limit, 100);

  -- Reset daily counter if new day
  IF v_quota.quota_reset_date < CURRENT_DATE THEN
    UPDATE meeting_quotas
    SET meetings_created_today = 0,
        quota_reset_date = CURRENT_DATE,
        updated_at = NOW()
    WHERE user_id = p_user_id;
    RETURN TRUE;
  END IF;

  -- Reset monthly counter if new month
  IF v_quota.monthly_quota_reset_date < DATE_TRUNC('month', CURRENT_DATE)::DATE THEN
    UPDATE meeting_quotas
    SET meetings_created_this_month = 0,
        monthly_quota_reset_date = DATE_TRUNC('month', CURRENT_DATE)::DATE,
        updated_at = NOW()
    WHERE user_id = p_user_id;
    RETURN TRUE;
  END IF;

  -- Check daily quota
  IF v_quota.meetings_created_today >= v_daily_limit THEN
    RAISE EXCEPTION 'Daily meeting quota exceeded. Maximum % meetings per day allowed.', v_daily_limit
      USING HINT = 'Please try again tomorrow or contact support to increase your limit',
            ERRCODE = 'P0001'; -- Custom error code for quota exceeded
  END IF;

  -- Check monthly quota
  IF v_quota.meetings_created_this_month >= v_monthly_limit THEN
    RAISE EXCEPTION 'Monthly meeting quota exceeded. Maximum % meetings per month allowed.', v_monthly_limit
      USING HINT = 'Please contact support to increase your limit',
            ERRCODE = 'P0002'; -- Custom error code for monthly quota exceeded
  END IF;

  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION check_meeting_quota IS 'Validates and enforces meeting creation quotas';

-- ============================================
-- 3. Quota Increment Function
-- ============================================

CREATE OR REPLACE FUNCTION increment_meeting_quota()
RETURNS TRIGGER AS $$
DECLARE
  v_created_by UUID;
BEGIN
  -- Determine who created the meeting
  -- Assume video_call_sessions has a created_by column
  -- If not, extract from related appointment
  IF TG_TABLE_NAME = 'video_call_sessions' THEN
    -- Get provider_id from appointment as creator
    SELECT provider_id INTO v_created_by
    FROM appointments
    WHERE id = NEW.appointment_id;

    IF v_created_by IS NULL THEN
      -- If provider is null, log warning but don't fail
      RAISE WARNING 'Could not determine creator for video call session %', NEW.id;
      RETURN NEW;
    END IF;
  ELSE
    RETURN NEW;
  END IF;

  -- Increment quota counters
  INSERT INTO meeting_quotas (
    user_id,
    meetings_created_today,
    meetings_created_this_month
  )
  VALUES (v_created_by, 1, 1)
  ON CONFLICT (user_id) DO UPDATE
  SET meetings_created_today = meeting_quotas.meetings_created_today + 1,
      meetings_created_this_month = meeting_quotas.meetings_created_this_month + 1,
      updated_at = NOW();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION increment_meeting_quota IS 'Increments meeting quota counters after session creation';

-- Create trigger on video_call_sessions
DROP TRIGGER IF EXISTS trigger_increment_meeting_quota ON video_call_sessions;
CREATE TRIGGER trigger_increment_meeting_quota
AFTER INSERT ON video_call_sessions
FOR EACH ROW
EXECUTE FUNCTION increment_meeting_quota();

-- ============================================
-- 4. HIPAA Audit Log Table
-- ============================================

-- Check if video_call_audit_log exists, if not create it
CREATE TABLE IF NOT EXISTS video_call_audit_log (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  appointment_id UUID REFERENCES appointments(id) ON DELETE SET NULL,
  meeting_id TEXT,
  action TEXT NOT NULL CHECK (action IN (
    'join_attempt',
    'join_attempt_unauthorized',
    'join_authorized',
    'join_success',
    'join_failure',
    'leave',
    'kicked',
    'timeout',
    'error'
  )),
  ip_address INET,
  user_agent TEXT,
  firebase_uid TEXT,
  supabase_uid UUID,
  error_message TEXT,
  metadata JSONB DEFAULT '{}'::JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE video_call_audit_log IS 'HIPAA-compliant audit log for all video call access attempts';
COMMENT ON COLUMN video_call_audit_log.action IS 'Type of video call action performed';
COMMENT ON COLUMN video_call_audit_log.metadata IS 'Additional context (user agent, device info, etc.)';

-- Indexes for efficient audit queries
CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON video_call_audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_appointment_id ON video_call_audit_log(appointment_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_meeting_id ON video_call_audit_log(meeting_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_action ON video_call_audit_log(action);
CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON video_call_audit_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_log_firebase_uid ON video_call_audit_log(firebase_uid);

-- Composite index for common queries
CREATE INDEX IF NOT EXISTS idx_audit_log_user_action_date
ON video_call_audit_log(user_id, action, created_at DESC);

-- Enable RLS
ALTER TABLE video_call_audit_log ENABLE ROW LEVEL SECURITY;

-- Users can view their own audit logs
CREATE POLICY "users_view_own_audit_logs" ON video_call_audit_log
FOR SELECT USING (
  auth.uid() = user_id
);

-- System admins can view all audit logs
CREATE POLICY "admins_view_all_audit_logs" ON video_call_audit_log
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role = 'system_admin'
  )
);

-- Facility admins can view audit logs for their facility's appointments
CREATE POLICY "facility_admins_view_facility_audit_logs" ON video_call_audit_log
FOR SELECT USING (
  EXISTS (
    SELECT 1
    FROM users
    INNER JOIN facility_admin_profiles ON facility_admin_profiles.user_id = users.id
    INNER JOIN appointments ON appointments.facility_id = facility_admin_profiles.facility_id
    WHERE users.id = auth.uid()
    AND users.role = 'facility_admin'
    AND appointments.id = video_call_audit_log.appointment_id
  )
);

-- No manual inserts allowed - only through application code or triggers
CREATE POLICY "no_direct_audit_log_insert" ON video_call_audit_log
FOR INSERT WITH CHECK (false);

-- No updates/deletes allowed (immutable audit log)
CREATE POLICY "no_audit_log_modifications" ON video_call_audit_log
FOR UPDATE USING (false);

CREATE POLICY "no_audit_log_deletions" ON video_call_audit_log
FOR DELETE USING (false);

-- ============================================
-- 5. Security Event Tracking Table
-- ============================================

CREATE TABLE IF NOT EXISTS security_events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  event_type TEXT NOT NULL CHECK (event_type IN (
    'rate_limit_exceeded',
    'unauthorized_access_attempt',
    'suspicious_activity',
    'quota_exceeded',
    'invalid_signature',
    'timing_violation',
    'geo_blocked'
  )),
  severity TEXT NOT NULL DEFAULT 'medium' CHECK (severity IN ('low', 'medium', 'high', 'critical')),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  ip_address INET,
  user_agent TEXT,
  request_path TEXT,
  request_method TEXT,
  error_message TEXT,
  metadata JSONB DEFAULT '{}'::JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE security_events IS 'Tracks security events for monitoring and alerting';

-- Indexes
CREATE INDEX IF NOT EXISTS idx_security_events_type ON security_events(event_type);
CREATE INDEX IF NOT EXISTS idx_security_events_severity ON security_events(severity);
CREATE INDEX IF NOT EXISTS idx_security_events_user_id ON security_events(user_id);
CREATE INDEX IF NOT EXISTS idx_security_events_created_at ON security_events(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_security_events_ip ON security_events(ip_address);

-- Enable RLS
ALTER TABLE security_events ENABLE ROW LEVEL SECURITY;

-- Only system admins can view security events
CREATE POLICY "admins_view_security_events" ON security_events
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE users.id = auth.uid()
    AND users.role = 'system_admin'
  )
);

-- No manual inserts/updates/deletes
CREATE POLICY "no_direct_security_event_modifications" ON security_events
FOR ALL USING (false);

-- ============================================
-- 6. Materialized View: Quota Usage Summary
-- ============================================

CREATE MATERIALIZED VIEW IF NOT EXISTS quota_usage_summary AS
SELECT
  u.id AS user_id,
  u.email,
  u.role,
  COALESCE(mq.meetings_created_today, 0) AS meetings_today,
  COALESCE(mq.daily_quota_limit, 10) AS daily_limit,
  COALESCE(mq.meetings_created_this_month, 0) AS meetings_this_month,
  COALESCE(mq.monthly_quota_limit, 100) AS monthly_limit,
  ROUND(
    (COALESCE(mq.meetings_created_today, 0)::NUMERIC / COALESCE(mq.daily_quota_limit, 10) * 100),
    2
  ) AS daily_usage_percent,
  ROUND(
    (COALESCE(mq.meetings_created_this_month, 0)::NUMERIC / COALESCE(mq.monthly_quota_limit, 100) * 100),
    2
  ) AS monthly_usage_percent,
  mq.quota_reset_date,
  mq.monthly_quota_reset_date
FROM users u
LEFT JOIN meeting_quotas mq ON mq.user_id = u.id
WHERE u.role IN ('medical_provider', 'facility_admin')
ORDER BY meetings_this_month DESC;

COMMENT ON MATERIALIZED VIEW quota_usage_summary IS 'Summary of quota usage across all users';

-- Create unique index for concurrent refresh
CREATE UNIQUE INDEX IF NOT EXISTS idx_quota_summary_user_id ON quota_usage_summary(user_id);

-- Refresh function (call periodically via cron or manually)
CREATE OR REPLACE FUNCTION refresh_quota_usage_summary()
RETURNS VOID AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY quota_usage_summary;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 7. Helper Functions for Edge Functions
-- ============================================

-- Function to log audit events (callable from Edge Functions)
CREATE OR REPLACE FUNCTION log_video_call_audit_event(
  p_user_id UUID,
  p_appointment_id UUID,
  p_meeting_id TEXT,
  p_action TEXT,
  p_firebase_uid TEXT DEFAULT NULL,
  p_supabase_uid UUID DEFAULT NULL,
  p_error_message TEXT DEFAULT NULL,
  p_ip_address TEXT DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO video_call_audit_log (
    user_id,
    appointment_id,
    meeting_id,
    action,
    firebase_uid,
    supabase_uid,
    error_message,
    ip_address,
    user_agent
  )
  VALUES (
    p_user_id,
    p_appointment_id,
    p_meeting_id,
    p_action,
    p_firebase_uid,
    p_supabase_uid,
    p_error_message,
    p_ip_address::INET,
    p_user_agent
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION log_video_call_audit_event IS 'Logs video call audit events (bypasses RLS for system use)';

-- Function to log security events
CREATE OR REPLACE FUNCTION log_security_event(
  p_event_type TEXT,
  p_severity TEXT,
  p_user_id UUID DEFAULT NULL,
  p_error_message TEXT DEFAULT NULL,
  p_ip_address TEXT DEFAULT NULL,
  p_user_agent TEXT DEFAULT NULL,
  p_request_path TEXT DEFAULT NULL,
  p_request_method TEXT DEFAULT NULL,
  p_metadata JSONB DEFAULT '{}'::JSONB
)
RETURNS UUID AS $$
DECLARE
  v_event_id UUID;
BEGIN
  INSERT INTO security_events (
    event_type,
    severity,
    user_id,
    error_message,
    ip_address,
    user_agent,
    request_path,
    request_method,
    metadata
  )
  VALUES (
    p_event_type,
    p_severity,
    p_user_id,
    p_error_message,
    p_ip_address::INET,
    p_user_agent,
    p_request_path,
    p_request_method,
    p_metadata
  )
  RETURNING id INTO v_event_id;

  RETURN v_event_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION log_security_event IS 'Logs security events for monitoring (bypasses RLS for system use)';

-- ============================================
-- 8. Data Retention Policy (HIPAA: 7 years)
-- ============================================

-- Function to archive old audit logs (run monthly via cron)
CREATE OR REPLACE FUNCTION archive_old_audit_logs()
RETURNS INTEGER AS $$
DECLARE
  v_archived_count INTEGER;
  v_retention_date TIMESTAMPTZ;
BEGIN
  -- HIPAA requires 7 years retention
  v_retention_date := NOW() - INTERVAL '7 years';

  -- Archive to separate table (if exists) or delete
  -- For now, we'll just count what would be deleted
  SELECT COUNT(*) INTO v_archived_count
  FROM video_call_audit_log
  WHERE created_at < v_retention_date;

  -- TODO: Move to archive table instead of deleting
  -- DELETE FROM video_call_audit_log WHERE created_at < v_retention_date;

  RAISE NOTICE 'Would archive % audit log entries older than %', v_archived_count, v_retention_date;

  RETURN v_archived_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 9. Grant Necessary Permissions
-- ============================================

-- Grant execute permissions to authenticated users
GRANT EXECUTE ON FUNCTION check_meeting_quota(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION log_video_call_audit_event TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION log_security_event TO authenticated, service_role;

-- Grant permissions for service role (Edge Functions)
GRANT ALL ON TABLE meeting_quotas TO service_role;
GRANT ALL ON TABLE video_call_audit_log TO service_role;
GRANT ALL ON TABLE security_events TO service_role;

-- Grant read access on summary view to admins
GRANT SELECT ON quota_usage_summary TO authenticated;

-- ============================================
-- 10. Validation & Testing
-- ============================================

-- Test quota enforcement
DO $$
BEGIN
  -- Test creating quota for test user
  PERFORM check_meeting_quota('00000000-0000-0000-0000-000000000000'::UUID);
  RAISE NOTICE 'Quota check function working correctly';
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Quota check test failed: %', SQLERRM;
END $$;

-- Verify RLS policies are enabled
DO $$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM pg_policies
  WHERE tablename IN ('meeting_quotas', 'video_call_audit_log', 'security_events');

  IF v_count < 8 THEN
    RAISE WARNING 'Not all RLS policies were created. Expected at least 8, got %', v_count;
  ELSE
    RAISE NOTICE 'All RLS policies created successfully (% policies)', v_count;
  END IF;
END $$;

-- ============================================
-- Migration Complete
-- ============================================
-- Summary:
-- ✅ Created meeting_quotas table with RLS
-- ✅ Created quota enforcement functions
-- ✅ Created video_call_audit_log table (HIPAA-compliant)
-- ✅ Created security_events table
-- ✅ Created materialized view for quota monitoring
-- ✅ Created helper functions for Edge Functions
-- ✅ Set up data retention policies
-- ✅ Configured RLS policies for all tables
--
-- Next steps:
-- 1. Deploy migration: npx supabase db push
-- 2. Update Edge Functions to use new functions
-- 3. Set up cron job to refresh quota_usage_summary
-- 4. Configure monitoring alerts for quota exceeded events
-- ============================================
